package block

import (
	"bytes"
	"encoding/binary"
	"time"

	c "github.com/fluxchain/core/crypto"
	"golang.org/x/crypto/blake2b"
)

type Header struct {
	Height     uint32    `json:"height"`
	Hash       c.Hash    `json:"hash"`
	PrevHash   c.Hash    `json:"prevhash"`
	Timestamp  time.Time `json:"timestamp"`
	MerkleRoot c.Hash    `json:"merkleroot"`
	Nonce      uint64    `json:"nonce"`
}

// Calculates the blockheader hash by concatting the previous blockhash, the
// merlkeroot, the height as a BE uint64 and the nonce as a BE uint64. And
// passing it through a round of SHA256
func (h Header) CalculateHash() (c.Hash, error) {
	hash, err := blake2b.New256(nil)
	if err != nil {
		return nil, err
	}

	hash.Write(h.PrevHash)
	hash.Write(h.MerkleRoot)

	tsBuf := make([]byte, 8)
	binary.BigEndian.PutUint64(tsBuf, uint64(h.Height))
	hash.Write(tsBuf)

	tsBuf = make([]byte, 8)
	binary.BigEndian.PutUint64(tsBuf, uint64(h.Nonce))
	hash.Write(tsBuf)

	md := hash.Sum(nil)
	return md, nil
}

// Generates a proof-of-work by simply generating a blockhash and checking if
// the first 4 characters are all zeroes. Need to rework this.
func (h *Header) GeneratePOW() []byte {
	var err error
	var hash c.Hash

	for {
		hash, err = h.CalculateHash()
		if err != nil {
			panic(err)
		}

		hashStr := hash.String()

		if hashStr[:4] == "0000" {
			break
		}

		h.Nonce += 1
	}

	return hash
}

// Checks if the resulting block hash generated by local calculations matches
// the blockheader hash.
func (h *Header) ValidatePOW() (bool, error) {
	headerHash := h.Hash
	calculatedHash, err := h.CalculateHash()

	if err != nil {
		return false, err
	}

	return bytes.Equal(headerHash, calculatedHash), nil
}
