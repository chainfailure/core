package blockchain

import (
	"crypto/sha256"
	"encoding/binary"
	"time"

	"github.com/fluxchain/core/util"
)

type BlockHeader struct {
	Height     uint32    `json:"height"`
	Hash       util.Hash `json:"hash"`
	PrevHash   util.Hash `json:"prevhash"`
	Timestamp  time.Time `json:"timestamp"`
	MerkleRoot util.Hash `json:"merkleroot"`
	Nonce      uint64    `json:"nonce"`
}

// Calculates the blockheader hash by concatting the previous blockhash, the
// merlkeroot, the height as a BE uint64 and the nonce as a BE uint64. And
// passing it through a round of SHA256
func (h BlockHeader) CalculateHash() util.Hash {
	hash := sha256.New()

	hash.Write(h.PrevHash)
	hash.Write(h.MerkleRoot)

	tsBuf := make([]byte, 8)
	binary.BigEndian.PutUint64(tsBuf, uint64(h.Height))
	hash.Write(tsBuf)

	tsBuf = make([]byte, 8)
	binary.BigEndian.PutUint64(tsBuf, uint64(h.Nonce))
	hash.Write(tsBuf)

	md := hash.Sum(nil)
	return md
}

// Generates a proof-of-work by simply generating a blockhash and checking if
// the first 4 characters are all zeroes. Need to rework this.
func (h *BlockHeader) GeneratePOW() []byte {
	var hash util.Hash

	for {
		hash = h.CalculateHash()
		hashStr := hash.String()

		if hashStr[:4] == "0000" {
			break
		}

		h.Nonce += 1
	}

	return hash
}

// Checks if the resulting block hash generated by local calculations matches
// the blockheader hash.
func (h *BlockHeader) ValidatePOW() bool {
	// TODO rework this all together
	return h.CalculateHash().String() == h.Hash.String()
}
