package blockchain

import (
	"crypto"
	"time"

	util "github.com/ipfs/go-ipfs-util"
)

type Header struct {
	Version    uint64      `json:"version"`
	Height     uint64      `json:"height"`
	PrevHash   crypto.Hash `json:"prevhash"`
	Timestamp  time.Time   `json:"timestamp"`
	MerkleRoot crypto.Hash `json:"merkleroot"`
	Nonce      uint64      `json:"nonce"`
	NTx        uint64      `json:"ntransactions`
}

// NewHeader returns a new block header
func NewHeader(height uint64, parenthash crypto.Hash, merkleproof crypto.Hash, time int64, bits uint64, nonce uint64, ntx uint64) *Header {
	return &Header{
		Height:        height,
		ParentHash:    parenthash,
		MerkleProof:   merkleproof,
		Time:          time,
		Bits:          bits,
		Nonce:         nonce,
		NTransactions: ntx,
	}
}

// Calculates the Header hash by concatting the previous blockhash, the
// merlkeroot, the height as a BE uint64 and the nonce as a BE uint64. And
// passing it through a round of SHA256
func (h Header) CalculateHash() crypto.Hash {

}

// Generates a proof-of-work by simply generating a blockhash and checking if
// the first 4 characters are all zeroes. Need to rework this.
func (h *Header) GeneratePOW() []byte {
	var hash util.Hash

	for {
		hash = h.CalculateHash()
		hashStr := hash.String()

		if hashStr[:4] == "0000" {
			break
		}

		h.Nonce++
	}

	return hash
}

// Checks if the resulting block hash generated by local calculations matches
// the Header hash.
func (h *Header) ValidatePOW() bool {
	// TODO rework this all together
	return h.CalculateHash().String() == h.Hash.String()
}
